
name: ci_full_build_$(Rev:r)
pool:
  vmImage: 'ubuntu-latest'
trigger:
  batch: true
  branches:
    include:
    - main
    - $(Build.SourceBranchName)
    exclude:
    - '*'
  paths:
    include:
    - src/edge/conquest/*
    - src/backned/*
    - src/agent/*
    exclude:
    - '*'    

resources:
- repo: self

variables:
- group: arm-vg
- group: iac-backend-vg
- group: aks-backend-vg
- group: backend-secrets-vg


- name: TIMELABEL
  value: $(date +%Y%m%d%H%M%S)
- name: GitBuildNumber
  value: $(Build.BuildId)
- name: registryName
  value: 'iotimageacr'
- name: pipelineAcrConnection
  value: 'iotacr'
- name: isSelectedImageAll
  value: ${{ eq(parameters.image, 'all') }}





parameters:
  - name: env
    displayName: Select Environment to deploy
    type: string
    default: dev
    values:
    - tst
    - dev
    - stg
    - prd    
  - name: image
    displayName: Select Image to Build and Scan
    type: string
    default: all
    values:
    - beapi
    - edge_conquest
    - iotlistener
    - all
    - analyzer
    - blobstreamer
    - keyholder
    - mongowriter
    - twinlistener    

stages:



  - stage: GetBackendImagesJsonStage # Stage 1
    jobs:
    - job: GetBackendImagesJsonJob
      displayName: Get Backend Images Json
      steps:
      - task: Bash@3
        name: SetBackendImagesJson
        inputs:
          targetType: 'inline'
          script: |
            images=$(cat ./src/images.json | jq -c .) # Compact JSON
            echo "##vso[task.setvariable variable=images;isOutput=true]$images"
            echo "##vso[task.setvariable variable=images]$images"

            echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
            echo "$images"
            echo -e "\n\n"
        displayName: Set Backend Images Json as Variable

  - stage: GetSingleBackendImageStage # Stage 2
    dependsOn: GetBackendImagesJsonStage
    condition: eq(variables['isSelectedImageAll'], false)
    jobs:
    - job: GetSingleBackendImageJob
      displayName: Get Single Backend Image Job
      variables:
        images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]
      steps:
      - script: |
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
          echo "$imagesJson"
          echo -e "\n\n"
          for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${img} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            if [ "$imgName" == "${{ parameters.image }}" ]; then
              imageName=$(_jq '.imageName')
              imagePath=$(_jq '.imagePath')
              dockerFilePath=$(_jq '.dockerFilePath')
              imageVersion=$(_jq '.imageVersion')
              # if [ "$imgName" != "edge_conquest" ]; then
              #   # imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
              # fi
              echo "##vso[task.setvariable variable=imageName]$imageName"
              echo "##vso[task.setvariable variable=imageVersion]$imageVersion"
              echo "##vso[task.setvariable variable=imagePath]$imagePath"
              echo "##vso[task.setvariable variable=dockerFilePath]$dockerFilePath"

              echo "##vso[task.setvariable variable=imageName;isOutput=true]$imageName"
              echo "##vso[task.setvariable variable=imageVersion;isOutput=true]$imageVersion"
              echo "##vso[task.setvariable variable=imagePath;isOutput=true]$imagePath"
              echo "##vso[task.setvariable variable=dockerFilePath;isOutput=true]$dockerFilePath"
              # Further processing logic here
            fi
          done
        name: SetSingleBackendImagesJson

  - stage: CleanBuildScanPushSingleBackendImageStage
    displayName: Build Tag Scan Push Image
    dependsOn: 
    - GetBackendImagesJsonStage
    - GetSingleBackendImageStage
    condition: eq(variables['isSelectedImageAll'], false)
    variables:
      images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]
      imageName: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imageName'] ]
      imageVersion: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imageVersion'] ]
      imagePath: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imagePath'] ]
      dockerFilePath: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.dockerFilePath'] ]      

    jobs:
    - job: CleanAllDockerImagesJob
      displayName: Clean All Docker Images & Containers
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/clean.yml


    - job: BuildTagSignleBackendImageJob
      dependsOn: 
      - CleanAllDockerImagesJob
      displayName: Build and Tag Single Backend Image
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent      
      steps:
      - script: |
          echo $(imageVersion)
          major=$(echo $(imageVersion) | cut -d '.' -f 1)
          minor=$(echo $(imageVersion) | cut -d '.' -f 2)
          oldBuild=$(echo $(imageVersion) | cut -d '.' -f 3)
          oldTime=$(echo $(imageVersion) | cut -d '.' -f 3)
          newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)      

      - template: templates/build.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          imagePath: $(imagePath)
          dockerFilePath: $(dockerFilePath)
          registryName: $(registryName)
          pipelineAcrConnection: $(pipelineAcrConnection)

    - job: ScanSignleBackendImage
      dependsOn: 
      - CleanAllDockerImagesJob
      - BuildTagSignleBackendImageJob
      displayName: Scan Single Backend Image 
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/scan.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          registryName: $(registryName)

    - job: PushSignleBackendImageJob
      dependsOn: 
      - CleanAllDockerImagesJob
      - BuildTagSignleBackendImageJob
      - ScanSignleBackendImage
      displayName: Push Single Backend Image 
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/push.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          registryName: $(registryName)



  - stage: CleanBuildScanPushAllBackendImagesStageBackendImagesStage
    displayName: Build Tag Scan Push All Backend Backend Images
    dependsOn: 
    - GetBackendImagesJsonStage
    condition: eq(variables['isSelectedImageAll'], true)
    variables:
      images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]

    jobs:
    - job: All
      displayName: Clean Tag Scan Push All Images
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:   
      - script: |   
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
          echo "$imagesJson"
          echo -e "\n\n"
          az login --service-principal -u $(iac-app-client-id) -p $(iac-app-client-secret) --tenant $(ARM_TENANT_ID)
          az account set --subscription $(ARM_SUBSCRIPTION_ID)
          echo "Azure Login Successfull"
          az acr login -n $(ACR_NAME)
  
          for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${img} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            imageName=$(_jq '.imageName')
            imagePath=$(_jq '.imagePath')
            dockerFilePath=$(_jq '.dockerFilePath')
            imageVersion=$(_jq '.imageVersion')
            ACR_NAME=$(ACR_NAME)
            # if [ "$imgName" != "edge_conquest" ]; then
            #   imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
            # fi        
            echo $(imageVersion)
            major=$(echo $imageVersion | cut -d '.' -f 1)
            minor=$(echo $imageVersion | cut -d '.' -f 2)
            oldBuild=$(echo $imageVersion | cut -d '.' -f 3)
            oldTime=$(echo $imageVersion | cut -d '.' -f 3)
            
            newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)

            echo -e "\n\n"
            echo "Clean Old Imaged"
            docker image prune -a --force
            docker image ls
            
            echo "Processing image: $imgName"
            echo "Image Version: $newVersion"
            echo ""
            echo -e "================================================\n\tBase Info Version\n================================================"
            find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'            

            echo -e "\n\n"
            echo -e "================================================\n\tUpdated Tag\n================================================"
            TAG="$newVersion"
            echo "TAG: $TAG"
            if [ "$imageName" != *edge_conquest* ]; then      
              find $imagePath -name "*.csproj" -exec sed -i "s/1.0._BUILDNUM_._TIMESTAMP_/${TAG}/g" {} \; 
              find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'
            fi    

            echo -e "\n\n"
            echo -e "================================================\n\tDocker Build - \n================================================"
            
            echo "========================"
            docker build -t $ACR_NAME.azurecr.io/$imageName:$newVersion  -f $dockerFilePath $imagePath
            if [ $? -ne 0 ]; then
              echo "Docker Build Failed"
              exit 1
            fi
            docker images | grep $imageName       
            
            echo -e "\n\n"
            echo -e "================================================\n\tDocker Scan - \n================================================"            
            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image --severity HIGH,CRITICAL $ACR_NAME.azurecr.io/$imageName:$newVersion

            echo -e "\n\n"
            echo -e "================================================\n\tDocker Push - \n================================================"            
            docker push $ACR_NAME.azurecr.io/$imageName:$newVersion
          done
        name: BuildTagScanPushBackendImagesBackendImages


  - stage: BuildAgentPoCArtifactsStage
    displayName: Build Agent POC Artifacts
    condition: eq(variables['isSelectedImageAll'], true)
    jobs:
    - job: BuildAgentPoCArtifactsJob
      displayName: Build Agent POC Artifacts
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:      
    
    

      - task: Docker@2
        displayName: 'Docker Build & Tag Agent POC'
        condition: succeeded()
        inputs:
          command: 'build'
          repository: agent_poc
          dockerfile: './src/agent/poc/Dockerfile'
          tags: 'aux-build'

      - script: |
          IMAGE_NAME=aget_poc
          IMAGE_VERSION=aux-build
          CONTAINER_ID=$(docker create $IMAGE_NAME:$IMAGE_VERSION)
          docker cp $CONTAINER_ID:/app/cloudpillar.zip .
          docker rm $CONTAINER_ID
          mv ./app/cloudpillar.zip ./cloudpillar-poc-1.0.$(GitBuildNumber).zip
          ls -al ./cloudpillar-poc-1.0.$(GitBuildNumber).zip
        name: ExtractAgentPoCZip
        displayName: 'Extract POC cloudpillar-poc-1.0.$(GitBuildNumber).zip from Image'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish cloudpillar-poc-1.0.$(GitBuildNumber)-poc-1.0.$(GitBuildNumber).zip to Artifacts'
        condition: succeeded()
        inputs:
          pathtoPublish: './cloudpillar-poc-1.0.$(GitBuildNumber).zip' # Path to the zip file on the agent machine
          artifactName: 'cloudpillar' # Name for the artifact
          publishLocation: 'Container' # Publish to Azure Pipelines
