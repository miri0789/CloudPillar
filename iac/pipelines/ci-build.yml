
name: ci_full_build_$(Rev:r)
trigger:
  batch: true
  branches:
    include:
    - main
    - $(Build.SourceBranchName)
    exclude:
    - '*'
  paths:
    include:
    - src/edge/conquest/*
    - src/backned/*
    - src/agent/*
    exclude:
    - '*'    

resources:
- repo: self

variables:
- group: arm-vg
- group: iac-backend-vg
- group: aks-backend-vg
- group: backend-secrets-vg


- name: TIMELABEL
  value: $(date +%Y%m%d%H%M%S)
- name: GitBuildNumber
  value: $(Build.BuildId)
- name: registryName
  value: 'iotimageacr'
- name: pipelineAcrConnection
  value: 'iotacr'
- name: isSelectedAllBackendImages
  value: ${{ eq(parameters.image, 'all') }}





parameters:
  - name: env
    displayName: Select Environment to deploy
    type: string
    default: dev
    values:
    - tst
    - dev
    - stg
    - prd    
  - name: image
    displayName: Select Image to Build and Scan
    type: string
    default: all
    values:
    - all
    - edge_conquest
    - iotlistener
    - blobstreamer
    - keyholder       
  - name: agent
    displayName: Select Agent Project
    type: object
    default:
    - agent_project   
    - poc   

stages:



  - stage: GetBackendImagesJsonStage # Stage 1
    jobs:
    - job: GetBackendImagesJsonJob
      displayName: Get Backend Images Json
      steps:
      - task: Bash@3
        name: SetBackendImagesJson
        inputs:
          targetType: 'inline'
          script: |
            images=$(cat ./iac/pipelines/pipelines-data/backend-images.json | jq -c .) # Compact JSON
            echo "##vso[task.setvariable variable=images;isOutput=true]$images"
            echo "##vso[task.setvariable variable=images]$images"

            echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
            echo "$images"
            echo -e "\n\n"
        displayName: Set Backend Images Json as Variable

  # - stage: GetSingleBackendImageStage # Stage 2
  #   dependsOn: GetBackendImagesJsonStage
  #   condition: eq(variables['isSelectedAllBackendImages'], false)
  #   jobs:
  #   - job: GetSingleBackendImageJob
  #     displayName: Get Single Backend Image Job
  #     variables:
  #       images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]
  #     steps:
  #     - script: |
  #         imagesJson='$(images)'
  #         echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
  #         echo "$imagesJson"
  #         echo -e "\n\n"
  #         for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
  #           _jq() {
  #             echo ${img} | base64 --decode | jq -r ${1}
  #           }
  #           imgName=$(_jq '.name')
  #           if [ "$imgName" == "${{ parameters.image }}" ]; then
  #             imageName=$(_jq '.imageName')
  #             imagePath=$(_jq '.imagePath')
  #             dockerFilePath=$(_jq '.dockerFilePath')
  #             imageVersion=$(_jq '.imageVersion')
  #             # if [ "$imgName" != "edge_conquest" ]; then
  #             #   # imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
  #             # fi
  #             echo "##vso[task.setvariable variable=imageName]$imageName"
  #             echo "##vso[task.setvariable variable=imageVersion]$imageVersion"
  #             echo "##vso[task.setvariable variable=imagePath]$imagePath"
  #             echo "##vso[task.setvariable variable=dockerFilePath]$dockerFilePath"

  #             echo "##vso[task.setvariable variable=imageName;isOutput=true]$imageName"
  #             echo "##vso[task.setvariable variable=imageVersion;isOutput=true]$imageVersion"
  #             echo "##vso[task.setvariable variable=imagePath;isOutput=true]$imagePath"
  #             echo "##vso[task.setvariable variable=dockerFilePath;isOutput=true]$dockerFilePath"
  #             # Further processing logic here
  #           fi
  #         done
  #       name: SetSingleBackendImagesJson

  # - stage: CleanBuildScanPushSingleBackendImageStage
    # displayName: Build Tag Scan Push Image
    # dependsOn: 
    # - GetBackendImagesJsonStage
    # - GetSingleBackendImageStage
    # condition: eq(variables['isSelectedAllBackendImages'], false)
    # variables:
    #   images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]
    #   imageName: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imageName'] ]
    #   imageVersion: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imageVersion'] ]
    #   imagePath: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.imagePath'] ]
    #   dockerFilePath: $[ stageDependencies.GetSingleBackendImageStage.GetSingleBackendImageJob.outputs['SetSingleBackendImagesJson.dockerFilePath'] ]      

    # jobs:
    # - job: CleanAllDockerImagesJob
    #   displayName: Clean All Docker Images & Containers
    #   pool:
    #     name: $(AGENT_POOL)
    #     agent.name: aks-${{parameters.env}}-agent
    #   steps:
    #   - template: templates/clean.yml


    # - job: BuildTagSignleBackendImageJob
    #   dependsOn: 
    #   - CleanAllDockerImagesJob
    #   displayName: Build and Tag Single Backend Image
    #   pool:
    #     name: $(AGENT_POOL)
    #     agent.name: aks-${{parameters.env}}-agent      
    #   steps:
    #   - script: |
    #       echo $(imageVersion)
    #       major=$(echo $(imageVersion) | cut -d '.' -f 1)
    #       minor=$(echo $(imageVersion) | cut -d '.' -f 2)
    #       newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)      

    #   - template: templates/build.yml
    #     parameters:
    #       imageName: $(imageName)
    #       imageVersion: $(newVersion)
    #       imagePath: $(imagePath)
    #       dockerFilePath: $(dockerFilePath)
    #       registryName: $(registryName)
    #       pipelineAcrConnection: $(pipelineAcrConnection)

    # - job: ScanSignleBackendImage
    #   dependsOn: 
    #   - CleanAllDockerImagesJob
    #   - BuildTagSignleBackendImageJob
    #   displayName: Scan Single Backend Image 
    #   pool:
    #     name: $(AGENT_POOL)
    #     agent.name: aks-${{parameters.env}}-agent
    #   steps:
    #   - template: templates/scan.yml
    #     parameters:
    #       imageName: $(imageName)
    #       imageVersion: $(newVersion)
    #       registryName: $(registryName)

    # - job: PushSignleBackendImageJob
    #   dependsOn: 
    #   - CleanAllDockerImagesJob
    #   - BuildTagSignleBackendImageJob
    #   - ScanSignleBackendImage
    #   displayName: Push Single Backend Image 
    #   pool:
    #     name: $(AGENT_POOL)
    #     agent.name: aks-${{parameters.env}}-agent
    #   steps:
    #   - template: templates/push.yml
    #     parameters:
    #       imageName: $(imageName)
    #       imageVersion: $(newVersion)
    #       registryName: $(registryName)



  # - stage: CleanBuildScanPushAllBackendImagesStageBackendImagesStage
  #   displayName: Build Tag Scan Push All Backend Backend Images
  #   dependsOn: 
  #   - GetBackendImagesJsonStage
  #   condition: eq(variables['isSelectedAllBackendImages'], true)
  #   variables:
  #     images: $[ stageDependencies.GetBackendImagesJsonStage.GetBackendImagesJsonJob.outputs['SetBackendImagesJson.images'] ]

  #   jobs:
  #   - job: All
  #     displayName: Clean Tag Scan Push All Images
  #     pool:
  #       name: $(AGENT_POOL)
  #       agent.name: aks-${{parameters.env}}-agent
  #     steps:   
  #     - script: |   
  #         imagesJson='$(images)'
  #         echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
  #         echo "$imagesJson"
  #         echo -e "\n\n"
  #         az login --service-principal -u $(iac-app-client-id) -p $(iac-app-client-secret) --tenant $(ARM_TENANT_ID)
  #         az account set --subscription $(ARM_SUBSCRIPTION_ID)
  #         echo "Azure Login Successfull"
  #         az acr login -n $(ACR_NAME)
  
  #         for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
  #           _jq() {
  #             echo ${img} | base64 --decode | jq -r ${1}
  #           }
  #           imgName=$(_jq '.name')
  #           imageName=$(_jq '.imageName')
  #           imagePath=$(_jq '.imagePath')
  #           dockerFilePath=$(_jq '.dockerFilePath')
  #           imageVersion=$(_jq '.imageVersion')
  #           ACR_NAME=$(ACR_NAME)
  #           # if [ "$imgName" != "edge_conquest" ]; then
  #           #   imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
  #           # fi        
  #           echo $(imageVersion)
  #           major=$(echo $imageVersion | cut -d '.' -f 1)
  #           minor=$(echo $imageVersion | cut -d '.' -f 2)
            
  #           newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)

  #           echo -e "\n\n"
  #           echo "Clean Old Imaged"
  #           docker image prune -a --force
  #           docker image ls
            
  #           echo "Processing image: $imgName"
  #           echo "Image Version: $newVersion"
  #           echo ""
  #           echo -e "================================================\n\tBase Info Version\n================================================"
  #           find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'            

  #           echo -e "\n\n"
  #           echo -e "================================================\n\tUpdated Tag\n================================================"
  #           TAG="$newVersion"
  #           echo "TAG: $TAG"
  #           if [ "$imageName" != *edge_conquest* ]; then      
  #             find $imagePath -name "*.csproj" -exec sed -i "s/1.0._BUILDNUM_._TIMESTAMP_/${TAG}/g" {} \; 
  #             find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'
  #           fi    

  #           echo -e "\n\n"
  #           echo -e "================================================\n\tDocker Build - \n================================================"
            
  #           echo "========================"
  #           docker build -t $ACR_NAME.azurecr.io/$imageName:$newVersion  -f $dockerFilePath $imagePath
  #           if [ $? -ne 0 ]; then
  #             echo "Docker Build Failed"
  #             exit 1
  #           fi
  #           docker images | grep $imageName       
            
  #           echo -e "\n\n"
  #           echo -e "================================================\n\tDocker Scan - \n================================================"            
  #           docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image --severity HIGH,CRITICAL $ACR_NAME.azurecr.io/$imageName:$newVersion

  #           echo -e "\n\n"
  #           echo -e "================================================\n\tDocker Push - \n================================================"            
  #           docker push $ACR_NAME.azurecr.io/$imageName:$newVersion
  #         done
  #       name: BuildTagScanPushBackendImages

  - stage: GetAgentImagesJsonStage
    jobs:
    - job: GetAgentImagesJsonJob
      displayName: Get Agent Images Json
      steps:
      - task: Bash@3
        name: SetAgentImagesJson
        inputs:
          targetType: 'inline'
          script: |
            images=$(cat ./iac/pipelines/pipelines-data/agent-images.json | jq -c .) # Compact JSON
            echo "##vso[task.setvariable variable=images;isOutput=true]$images"
            echo "##vso[task.setvariable variable=images]$images"

            echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
            echo "$images"
            echo -e "\n\n"
        displayName: Set Backend Images Json as Variable

  - stage: BuildAgentArtifactsStage
    dependsOn: GetAgentImagesJsonStage
    jobs:
    - job: BuildAgentArtifactsJob
      displayName: Get Single Backend Image Job
      variables:
        images: $[ stageDependencies.GetAgentImagesJsonStage.GetAgentImagesJsonJob.outputs['SetAgentImagesJson.images'] ]
      steps:
      - script: |
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
          echo -e "${imagesJson}"
          for image in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${image} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
            echo -e "${image}"
            echo -e "${imgName}"
            echo "Processing image: $image"
            # Execute a task for each image
            echo "##vso[task.setvariable variable=currentImage]$image"
            echo "##vso[task.setvariable variable=processedImage]true"
            # Add more tasks here, each using the current image
          done
        displayName: Loop Through agent images and Execute Tasks
      
      
      - task: Docker@2
        condition: eq(variables.processedImage, true)
        displayName: 'Docker Build & Tag $(variables.currentImage.name)'
        inputs:
          command: 'build'
          repository: $(variables.currentImage.name)
          dockerfile: $(variables.currentImage.dockerFilePath)
          buildContext: 'src'
          tags: 'aux-build'

      - script: |
          CONTAINER_ID=$(docker create $(variables.currentImage.name):aux-build)
          docker cp $CONTAINER_ID:/app/cloudpillar.zip .
          docker rm $CONTAINER_ID
          mv ./cloudpillar.zip ./cloudpillar-$(variables.currentImage.name)-1.0.$(GitBuildNumber).zip
          ls -al ./cloudpillar-poc-$(variables.currentImage.imageVersion).$(GitBuildNumber).zip
        condition: eq(variables.processedImage, true)
        displayName: 'Extract POC cloudpillar.zip from Image'

      - task: PublishBuildArtifacts@1
        condition: eq(variables.processedImage, true)
        displayName: 'Publish cloudpillar.zip to Artifacts'
        inputs:
          pathtoPublish: './cloudpillar-$(variables.currentImage.name)-$(variables.currentImage.imageVersion).$(GitBuildNumber).zip' # Path to the zip file on the agent machine
          artifactName: 'cloudpillar' # Name for the artifact
          publishLocation: 'Container' # Publish to Azure Pipelines

      # - task: YourNextTask@Version  # Replace with the actual task you want to execute
      #   condition: eq(variables.processedImage, 'true')
      #   inputs:
      #     # Configure task inputs using the currentImage variable
      #     # ...
      #   displayName: Process Image Task
  #         script: |
  #           images=$(cat ./iac/pipelines/pipelines-data/agent-images.json | jq -c .) # Compact JSON
  #           echo "##vso[task.setvariable variable=agentJsonContent;isOutput=true]$images"
  #           echo "##vso[task.setvariable variable=agentJsonContent]$images"

  #           echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
  #           echo "$images"
  #           echo -e "\n\n"
  #       displayName: Set Agent Images Json as Variable

  # - stage: BuildAgentArtifactsStage
  #   dependsOn: GetAgentImagesJsonStage
  #   jobs:
  #   - job: BuildAgentPoCArtifactsJob
  #     displayName: Build Agent POC Artifacts
  #     variables:
  #       images: $[ stageDependencies.GetAgentImagesJsonStage.GetAgentImagesJsonJob.outputs['SetAgentImagesJson.images'] ] 
  #     steps:      
  #       - ${{ each item in variables.images }}:
  #         - ${{ if eq(parameters.agent, item.name) }}:
  #           - task: Docker@2
  #             displayName: 'Docker Build & Tag $(item.name)'
  #             inputs:
  #               command: 'build'
  #               repository: $(item.name)
  #               dockerfile: $(item.dockerFilePath)
  #               buildContext: 'src'
  #               tags: 'aux-build'

  #           - script: |
  #               CONTAINER_ID=$(docker create $(item.name):aux-build)
  #               docker cp $CONTAINER_ID:/app/cloudpillar.zip .
  #               docker rm $CONTAINER_ID
  #               mv ./cloudpillar.zip ./cloudpillar-$(item.name)-1.0.$(GitBuildNumber).zip
  #               ls -al ./cloudpillar-poc-$(item.imageVersion).$(GitBuildNumber).zip
  #             displayName: 'Extract POC cloudpillar.zip from Image'

  #           - task: PublishBuildArtifacts@1
  #             displayName: 'Publish cloudpillar.zip to Artifacts'
  #             inputs:
  #               pathtoPublish: './cloudpillar-$(item.name)-$(item.imageVersion).$(GitBuildNumber).zip' # Path to the zip file on the agent machine
  #               artifactName: 'cloudpillar' # Name for the artifact
  #               publishLocation: 'Container' # Publish to Azure Pipelines
