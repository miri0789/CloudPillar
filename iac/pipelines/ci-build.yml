
name: ci_full_build_$(Rev:r)

trigger:
  batch: true
  branches:
    include:
    - main
    - $(Build.SourceBranchName)
    exclude:
    - '*'
  paths:
    include:
    - src/edge/conquest/*
    - src/backned/*
    exclude:
    - '*'    

resources:
- repo: self

variables:
- group: arm-vg
- group: iac-backend-vg
- group: aks-backend-vg
- group: backend-secrets-vg


- name: TIMELABEL
  value: $(date +%Y%m%d%H%M%S)
- name: GitBuildNumber
  value: $(Build.BuildId)
- name: registryName
  value: 'iotimageacr'
- name: pipelineAcrConnection
  value: 'iotacr'
- name: isSelectedImageAll
  value: ${{ eq(parameters.image, 'all') }}





parameters:
  - name: env
    displayName: Select Environment to deploy
    type: string
    default: dev
    values:
    - tst
    - dev
    - stg
    - prd    
  - name: image
    displayName: Select Image to Build and Scan
    type: string
    default: all
    values:
    - beapi
    - edge_conquest
    - iotlistener
    - all
    - analyzer
    - blobstreamer
    - keyholder
    - mongowriter
    - twinlistener    

stages:



  - stage: GetImages # Stage 1
    jobs:
    - job: GetImagesJob
      displayName: Get Images Job
      steps:
      - task: Bash@3
        name: getImagesInfo
        inputs:
          targetType: 'inline'
          script: |
            images=$(cat ./src/images.json | jq -c .) # Compact JSON
            echo "##vso[task.setvariable variable=images;isOutput=true]$images"
            echo "##vso[task.setvariable variable=images]$images"

            echo -e "\n\n===================================================================\n\tImages\n===================================================================\n"
            echo "$images"
            echo -e "\n\n"
        displayName: Set Images as Variable

  - stage: GetSingleImage # Stage 2
    dependsOn: GetImages
    condition: eq(variables['isSelectedImageAll'], false)
    jobs:
    - job: GetSingleImageJob
      displayName: Get Single Image Job
      variables:
        images: $[ stageDependencies.GetImages.GetImagesJob.outputs['getImagesInfo.images'] ]
      steps:
      - script: |
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
          echo "$imagesJson"
          echo -e "\n\n"
          for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${img} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            if [ "$imgName" == "${{ parameters.image }}" ]; then
              imageName=$(_jq '.imageName')
              imagePath=$(_jq '.imagePath')
              dockerFilePath=$(_jq '.dockerFilePath')
              imageVersion=$(_jq '.imageVersion')
              # if [ "$imgName" != "edge_conquest" ]; then
              #   # imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
              # fi
              echo "##vso[task.setvariable variable=imageName]$imageName"
              echo "##vso[task.setvariable variable=imageVersion]$imageVersion"
              echo "##vso[task.setvariable variable=imagePath]$imagePath"
              echo "##vso[task.setvariable variable=dockerFilePath]$dockerFilePath"

              echo "##vso[task.setvariable variable=imageName;isOutput=true]$imageName"
              echo "##vso[task.setvariable variable=imageVersion;isOutput=true]$imageVersion"
              echo "##vso[task.setvariable variable=imagePath;isOutput=true]$imagePath"
              echo "##vso[task.setvariable variable=dockerFilePath;isOutput=true]$dockerFilePath"
              # Further processing logic here
            fi
          done
        name: getSingleImageInfo

  - stage: CleanBuildScanPush
    displayName: Build Tag Scan Push Image
    dependsOn: 
    - GetImages
    - GetSingleImage
    condition: eq(variables['isSelectedImageAll'], false)
    variables:
      images: $[ stageDependencies.GetImages.GetImagesJob.outputs['getImagesInfo.images'] ]
      imageName: $[ stageDependencies.GetSingleImage.GetSingleImageJob.outputs['getSingleImageInfo.imageName'] ]
      imageVersion: $[ stageDependencies.GetSingleImage.GetSingleImageJob.outputs['getSingleImageInfo.imageVersion'] ]
      imagePath: $[ stageDependencies.GetSingleImage.GetSingleImageJob.outputs['getSingleImageInfo.imagePath'] ]
      dockerFilePath: $[ stageDependencies.GetSingleImage.GetSingleImageJob.outputs['getSingleImageInfo.dockerFilePath'] ]      

    jobs:
    - job: CleanImages
      displayName: Clean Images & Containers
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/clean.yml


    - job: BuildTagImage
      dependsOn: 
      - CleanImages
      displayName: Build and Tag Image
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent      
      steps:
      - script: |
          echo $(imageVersion)
          major=$(echo $(imageVersion) | cut -d '.' -f 1)
          minor=$(echo $(imageVersion) | cut -d '.' -f 2)
          oldBuild=$(echo $(imageVersion) | cut -d '.' -f 3)
          oldTime=$(echo $(imageVersion) | cut -d '.' -f 3)
          newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)      

      - template: templates/build.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          imagePath: $(imagePath)
          dockerFilePath: $(dockerFilePath)
          registryName: $(registryName)
          pipelineAcrConnection: $(pipelineAcrConnection)

    - job: ScanImage
      dependsOn: 
      - CleanImages
      - BuildTagImage
      displayName: Scan Image 
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/scan.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          registryName: $(registryName)

    - job: PushImage
      dependsOn: 
      - CleanImages
      - BuildTagImage
      - ScanImage
      displayName: Push Image 
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:
      - template: templates/push.yml
        parameters:
          imageName: $(imageName)
          imageVersion: $(newVersion)
          registryName: $(registryName)



  - stage: CleanBuildScanPushAll
    displayName: Build Tag Scan Push All Images
    dependsOn: 
    - GetImages
    condition: eq(variables['isSelectedImageAll'], true)
    variables:
      images: $[ stageDependencies.GetImages.GetImagesJob.outputs['getImagesInfo.images'] ]

    jobs:
    - job: All
      displayName: Clean Tag Scan Push All Images
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:      
      - script: |    
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
          echo "$imagesJson"
          echo -e "\n\n"
          az login --service-principal -u $(iac-app-client-id) -p $(iac-app-client-secret) --tenant $(ARM_TENANT_ID)
          az account set --subscription $(ARM_SUBSCRIPTION_ID)
          echo "Azure Login Successfull"
          az acr login -n $(ACR_NAME)
  
          for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${img} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            imageName=$(_jq '.imageName')
            imagePath=$(_jq '.imagePath')
            dockerFilePath=$(_jq '.dockerFilePath')
            imageVersion=$(_jq '.imageVersion')
            ACR_NAME=$(ACR_NAME)
            # if [ "$imgName" != "edge_conquest" ]; then
            #   imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
            # fi        
            echo $(imageVersion) 
            major=$(echo $imageVersion | cut -d '.' -f 1)
            minor=$(echo $imageVersion | cut -d '.' -f 2)
            oldBuild=$(echo $imageVersion | cut -d '.' -f 3)
            oldTime=$(echo $imageVersion | cut -d '.' -f 3)
            
            newVersion=$major.$minor.$(GitBuildNumber).$(TIMELABEL)

            echo -e "\n\n"
            echo "Clean Old Imaged"
            docker image prune -a --force
            docker image ls
            
            echo "Processing image: $imgName"
            echo "Image Version: $newVersion"
            echo ""
            echo -e "================================================\n\tBase Info Version\n================================================"
            find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'            

            echo -e "\n\n"
            echo -e "================================================\n\tUpdated Tag\n================================================"
            TAG="$newVersion"
            echo "TAG: $TAG"
            if [ "$imageName" != *edge_conquest* ]; then      
              find $imagePath -name "*.csproj" -exec sed -i "s/1.0._BUILDNUM_._TIMESTAMP_/${TAG}/g" {} \; 
              find $imagePath -name "*.csproj" -print0 | xargs -0 grep -H "InformationalVersion" | awk -F':' '{n=split($1,a,"/"); printf "%s:%s\n", a[n], $2}'
            fi    

            echo -e "\n\n"
            echo -e "================================================\n\tDocker Build - \n================================================"
            docker build -t $ACR_NAME.azurecr.io/$imageName:$newVersion  -f $dockerFilePath  $imagePath
            docker images | grep $imageName       
            
            echo -e "\n\n"
            echo -e "================================================\n\tDocker Scan - \n================================================"            
            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image --severity HIGH,CRITICAL $ACR_NAME.azurecr.io/$imageName:$newVersion

            echo -e "\n\n"
            echo -e "================================================\n\tDocker Push - \n================================================"            
            docker push $ACR_NAME.azurecr.io/$imageName:$newVersion
          done
        name: BuildTagScanPush


    - job: BuildPSArtifacts
      displayName: Build Agent POC Artifacts
      dependOn: All
      pool:
        name: $(AGENT_POOL)
        agent.name: aks-${{parameters.env}}-agent
      steps:      
      - script: |
          imagesJson='$(images)'
          echo -e "\n\n===================================================================\n\tImages JSON\n===================================================================\n"
          echo "$imagesJson"
          echo -e "\n\n"
          for img in $(echo "${imagesJson}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${img} | base64 --decode | jq -r ${1}
            }
            imgName=$(_jq '.name')
            if [ "$imgName" == "agent_poc" ]; then
              imageName=$(_jq '.imageName')
              imagePath=$(_jq '.imagePath')
              dockerFilePath=$(_jq '.dockerFilePath')
              imageVersion=$(_jq '.imageVersion')
              # if [ "$imgName" != "edge_conquest" ]; then
              #   # imageVersion="$(major).$(minor).$(GitBuildNumber).$(TIMELABEL)"
              # fi

              echo "##vso[task.setvariable variable=imageName;isOutput=true]$imageName"
              echo "##vso[task.setvariable variable=imageVersion;isOutput=true]$imageVersion"
              echo "##vso[task.setvariable variable=imagePath;isOutput=true]$imagePath"
              echo "##vso[task.setvariable variable=dockerFilePath;isOutput=true]$dockerFilePath"
              # Further processing logic here
            fi
          done
        name: getAgentPoCImageInfo

      - task: Docker@2
        displayName: 'Docker Build & Tag Agent POC'
        condition: succeeded()
        inputs:
          command: 'build'
          repository: '$(getAgentPoCImageInfo.imageName)'
          dockerfile: '$(getAgentPoCImageInfo.dockerFilePath)'
          tags: '$(getAgentPoCImageInfo.imageVersion)'

      - script: |
          IMAGE_NAME=$(getAgentPoCImageInfo.imageName)
          IMAGE_VERSION=$(getAgentPoCImageInfo.imageVersion)
          CONTAINER_ID=$(docker create $IMAGE_NAME:$IMAGE_VERSION)
          docker cp $CONTAINER_ID:/app/cloudpillar.zip .
          docker rm $CONTAINER_ID
          mv ./cloudpillar.zip ./cloudpillar-poc-1.0.$(GitBuildNumber).zip
          ls -al ./cloudpillar-poc-1.0.$(GitBuildNumber).zip
        name: extractAgentPoCZip
        displayName: 'Extract POC cloudpillar.zip from Image'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish cloudpillar.zip to Artifacts'
        condition: succeeded()
        inputs:
          pathtoPublish: './cloudpillar-poc-1.0.$(GitBuildNumber).zip' # Path to the zip file on the agent machine
          # pathtoPublish: './cloudpillar.zip' # Path to the zip file on the agent machine
          artifactName: 'cloudpillar' # Name for the artifact
          publishLocation: 'Container' # Publish to Azure Pipelines
